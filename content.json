[{"title":"当NSAttributedString遇上链式编程","date":"2017-08-17T12:43:29.000Z","path":"2017/08/17/ktattributedstring/","text":"NSAttributedString是一种带有属性的字符串，通过它我们可以在一个字符串中实现不同的字体大小、字体颜色、删除线等功能。 可是它的使用经常是这样的： 123456NSDictionary *attributeDic = [NSDictionary dictionaryWithObjectsAndKeys: [UIFont systemFontOfSize:15.0],NSFontAttributeName, [UIColor redColor],NSForegroundColorAttributeName, @(NSUnderlineStyleSingle),NSUnderlineStyleAttributeName,nil]; NSMutableAttributedString *attributedString = [[NSMutableAttributedString alloc] initWithString:@&quot;Hello world&quot; attributes:attributeDic]; 又或者是这样的： 1234567NSMutableAttributedString *attributedString = [[NSMutableAttributedString alloc] initWithString:@&quot;Hello world&quot;];[attributedString addAttribute:NSFontAttributeName value:[UIFont systemFontOfSize:15.0] range:NSMakeRange(0, attributedString.length)];[attributedString addAttribute:NSForegroundColorAttributeName value:[UIColor redColor] range:NSMakeRange(0, attributedString.length)];[attributedString addAttribute:NSUnderlineStyleAttributeName value:@(NSUnderlineStyleSingle) range:NSMakeRange(0, attributedString.length)]; 当一个字符串拥有多种样式的时候，更是苦不堪言。 那么是否有什么优雅的方式可以解决这个问题呢？ Masonry与AutoLayoutMasonry是一个对系统NSLayoutConstraint进行封装的第三方自动布局框架，采用链式编程的方式提供给开发者API。 在使用Masonry之前我们的代码通常是这样的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445UIView *superview = self.view;UIView *view1 = [[UIView alloc] init];view1.translatesAutoresizingMaskIntoConstraints = NO;view1.backgroundColor = [UIColor greenColor];[superview addSubview:view1];UIEdgeInsets padding = UIEdgeInsetsMake(10, 10, 10, 10);[superview addConstraints:@[ //view1 constraints [NSLayoutConstraint constraintWithItem:view1 attribute:NSLayoutAttributeTop relatedBy:NSLayoutRelationEqual toItem:superview attribute:NSLayoutAttributeTop multiplier:1.0 constant:padding.top], [NSLayoutConstraint constraintWithItem:view1 attribute:NSLayoutAttributeLeft relatedBy:NSLayoutRelationEqual toItem:superview attribute:NSLayoutAttributeLeft multiplier:1.0 constant:padding.left], [NSLayoutConstraint constraintWithItem:view1 attribute:NSLayoutAttributeBottom relatedBy:NSLayoutRelationEqual toItem:superview attribute:NSLayoutAttributeBottom multiplier:1.0 constant:-padding.bottom], [NSLayoutConstraint constraintWithItem:view1 attribute:NSLayoutAttributeRight relatedBy:NSLayoutRelationEqual toItem:superview attribute:NSLayoutAttributeRight multiplier:1 constant:-padding.right], ]]; 当使用Masonry之后我们的代码是这样的： 123[view1 mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.edges.equalTo(superview).with.insets(padding);&#125;]; AutoLayout的代码书写无疑比NSAttributedString的还复杂的多，但经过Masonry的封装之后，我们使用起来可方便多了，感谢Masonry。 那么我们是否也能使用Masonry链式编程的思想来封装NSAttributedString呢? 链式编程分析1make.edges.equalTo(superview).with.insets(padding); 分析以上代码 用点语法的形式调用可以得出调用的应该是一个属性 调完一次之后能够接着继续调用可以得出应该是在每次调用之后返回了实例本身 能在括号里传参数，且有返回值，可以进一步得出这个属性是一个block NSAttributedString链式编程实现这里以一个color属性为例。 1.给NSMutableAttributedString创建分类，之所以是NSMutableAttributedString而不是NSAttributedString，是因为NSAttributedString是不可变的，不方便进行属性添加操作 2.创建color的block 1- (NSMutableAttributedString *(^)(UIColor *))color; 3.color的实现 123456- (NSMutableAttributedString *(^)(UIColor *))color &#123; return ^(UIColor *color) &#123; [self addAttributeName:NSForegroundColorAttributeName value:color]; return self; &#125;;&#125; 经过以上几步我们便能对一个NSMutableAttributedString的对象进行.color([UIColor redColor])的操作了。其它属性的封装同理。 一个关于删除线的Bug当我封装完成进行测试时，突然发现有时候设置删除线无效，即设置NSStrikethroughStyleAttributeName的时候，该情况发生在iOS10.3。 我在StackOverflow上搜了一下，发现很多人也遇到了这个问题，应该是iOS10.3的一个bug，具体出现的场景还不太清楚，如果有人知道的话可以和我讨论下。 解决方法是同时添加NSBaselineOffsetAttributeName属性。 我最后封装的效果图如下： GitHub地址 如果觉得对您有帮助的话请给我一个Star，如果有bug的话可以给我提Issues，我会尽快解决。 参考 https://github.com/SnapKit/Masonry https://github.com/Draveness/Typeset http://www.jianshu.com/p/0bf1a7052d25 https://stackoverflow.com/questions/43070335/nsstrikethroughstyleattributename-how-to-strike-out-the-string-in-ios-10-3 https://stackoverflow.com/questions/25956183/nsmutableattributedstrings-attribute-nsstrikethroughstyleattributename-doesnt","tags":[{"name":"iOS","slug":"iOS","permalink":"//breadawesome.me/tags/iOS/"}]},{"title":"LeetCode Day3 - Reverse Integer","date":"2017-08-14T12:50:42.000Z","path":"2017/08/14/leetcode-day3/","text":"一、前言找工作这段闹心的日子，继续刷题吧… 二、ProblemReverse Integer Reverse digits of an integer. Example1: x = 123, return 321Example2: x = -123, return -321 Note:The input is assumed to be a 32-bit signed integer. Your function should return 0 when the reversed integer overflows. 问题的意思是给一个整数，进行反转后再返回。如果反转后溢出了，则返回0。 三、Solution思路是将输入的整数转化为字符串，遍历该字符串的characters.reversed(),创建一个新字符串，如果遇到“-”号则插入到该字符串最前面，否则就插入到该字符串后面。最后使用可选绑定判断是否溢出，进行相应的返回。 代码如下： 1234567891011121314151617181920class Solution &#123; func reverse(_ x: Int) -&gt; Int &#123; let oldString = String(x) var newString = String() for character in oldString.characters.reversed() &#123; if character == &quot;-&quot; &#123; newString.insert(character, at: newString.startIndex) &#125;else &#123; newString.append(character) &#125; &#125; if let result = Int32(newString) &#123; return Int(result) &#125;else &#123; return 0 &#125; &#125;&#125;","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"//breadawesome.me/tags/LeetCode/"}]},{"title":"LeetCode Day2 - Add Two Numbers","date":"2017-08-10T04:22:20.000Z","path":"2017/08/10/leetcode-day2/","text":"一、前言又是阳光灿烂的一天，那就废话不多说，开始今天的刷题。 二、Problem Add Two NumbersYou are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8 问题的意思也很浅显易懂，给两个链表，计算它们相加之后的值。 三、Solution思路的话也蛮简单的，链表的每一个节点分别相加，将进位传到下一个节点。如果两个链表长度不一样，则给短的补零，使它们长度一样。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738//Definition for singly-linked list.public class ListNode &#123; public var val: Int public var next: ListNode? public init(_ val: Int) &#123; self.val = val self.next = nil &#125;&#125;class Solution &#123; func addTwoNumbers(_ l1: ListNode?, _ l2: ListNode?) -&gt; ListNode? &#123; var carry = 0 var list1 = l1 var list2 = l2 var list3: ListNode? = ListNode(0) var node = list3 while list1 != nil || list2 != nil &#123; let list1Vaule = list1?.val != nil ? list1!.val : 0 let list2Vaule = list2?.val != nil ? list2!.val : 0 node?.next = ListNode((list1Vaule + list2Vaule + carry) % 10) node = node?.next carry = (list1Vaule + list2Vaule + carry) / 10 list1 = list1?.next list2 = list2?.next &#125; if (carry &gt; 0) &#123; node?.next = ListNode(carry) &#125; list3 = list3?.next return list3 &#125;&#125; 开始我没有考虑到最后一次进位的情况，也就是以下代码没写 123if (carry &gt; 0) &#123; node?.next = ListNode(carry)&#125; 然后提交之后，LeetCode报了一个Wrong Answer的错 可以说是非常人性了。但在平时自己写代码的过程中我们还是要尽可能多的考虑情况，毕竟那时候没人会提醒你了。话说我觉得这个算法可以用来解决两个超大数的相加，你觉得呢？ 惯例放上GitHub地址：https://github.com/BreadAwesome/LeetCode-Swift","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"//breadawesome.me/tags/LeetCode/"}]},{"title":"LeetCode Day1 - Two Sum","date":"2017-08-09T07:08:32.000Z","path":"2017/08/09/leetcode-day1/","text":"一、前言LeetCode也支持Swift了，离职在家，闲来无事，便想着刷几道玩玩，既可以学习一下算法，又可以保持自己的编程状态。 二、ProblemTwo Sum Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: 1234Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 问题的意思是给一个整数数组，再给一个目标值，找出数组中相加等于目标值的两个数，然后将它们的索引作为一个新的数组返回。这里假设只有一个解决方案，也就是说不存在会有两组数相加等于目标值。 三、Solution开始我的思路是这样的： 判断数组的count是否小于2，如果小于2则直接返回一个空数组 这里假设数组参数名为nums,设定两个变量start和end，start初始为0,end为nums.cout - 2，当strat &lt;= end的时候进行循环，nums[start]分别尝试与nums[start + 1]…nums[nums.count - 1]相加，如果等于目标值，则返回对应的索引数组，如果不等于目标值则继续循环，每次循环完成后将start值加1。 遍历完成之后仍没有结果的话则返回一个空数组 代码如下： 1234567891011121314151617181920212223242526class Solution &#123; func twoSum(_ nums: [Int], _ target: Int) -&gt; [Int] &#123; if nums.count &lt; 2 &#123; return [Int]() &#125; var start = 0 let end = nums.count - 2 while start &lt;= end &#123; let firstNum = nums[start] for (index, secondNum) in nums[(start + 1)..&lt;nums.count].enumerated() &#123; if firstNum + secondNum == target &#123; return [start, start + 1 + index] &#125; &#125; start += 1 &#125; return [Int]() &#125;&#125; 提交之后 发现有一个case超时了，确实当数组数量很多的时候需要遍历很多次，这样会花费很多的时间。 数组就不贴出来了，我只知道当我复制进去的时候连Xcode都为之一卡。 那么有什么好的办法可以减少时间耗费呢？ 我去看了下这个问题的Discuss，发现了一种很好的思路，那就是使用字典。只需遍历一次，将遍历得到的(index, value)的value作为键，index作为值，然后每次查找时判断目标值 - value这个键在字典中是否存在即可。 代码如下： 12345678910111213141516171819class Solution &#123; func twoSum(_ nums: [Int], _ target: Int) -&gt; [Int] &#123; var map = [Int: Int]() var resultArray = [Int]() for (index, value) in nums.enumerated() &#123; if let firstIndex = map[target - value] &#123; resultArray.append(firstIndex) resultArray.append(index) break &#125;else &#123; map[value] = index &#125; &#125; return resultArray &#125;&#125; 不得不说思路的转变节省了大量的时间，程序员也要学习算法啊。 我在GitHub上新建了一个仓库，作为我刷题的记录，大家有兴趣的话也可以去看看。 GitHub地址：https://github.com/BreadAwesome/LeetCode-Swift","tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"//breadawesome.me/tags/LeetCode/"}]},{"title":"iOS自动化打包发布（Jenkins + Fastlane + GitLab + 蒲公英）","date":"2017-07-14T08:45:53.000Z","path":"2017/07/14/CI/","text":"前言在项目测试阶段，频繁的打包发布会耗费团队很多的时间。搭建一个自动化打包发布的平台，可以将我们从那些繁琐的打包发布流程中解放出来。 本文采用的方案是：Jenkins + Fastlane + GitLab + 蒲公英。 Fastlane安装Fastlane是一套使用Ruby写的自动化工具集，用于iOS和Android的自动化打包、发布等工作，可以节省大量的时间。 安装过程如下：1.检查Ruby版本，需要2.0及以上版本。在终端输入以下命令确认： 1ruby -v 需要注意的是需要将gem的source改为https://gems.ruby-china.org/。如何检查?在终端输入以下命令: 1gem sources 结果应为： 123*** CURRENT SOURCES ***https://gems.ruby-china.org/ 2.检查Xcode命令行工具是否安装。在终端输入以下命令： 1xcode-select --install 如果没有安装会进行安装。如果已经安装了则会提示： 1xcode-select: error: command line tools are already installed, use &quot;Software Update&quot; to install updates 3.安装Fastlane 1sudo gem install fastlane --verbose 如果出现以下错误： 12ERROR: While executing gem ... (Errno::EPERM) Operation not permitted - /usr/bin/rougify 则输入以下命令： 1sudo gem install -n /usr/local/bin fastlane 4.检查Fastlane是否正确安装。输入以下命令： 1fastlane --version 可以看到Fastlane版本信息，我的是2.46.1。 蒲公英的Fastlane插件安装打开终端，进入你的项目工程的根目录，输入以下命令： 1fastlane add_plugin pgyer 出现 123456Plugin &apos;fastlane-plugin-pgyer&apos; was added to &apos;./fastlane/Pluginfile&apos;It looks like fastlane plugins are not yet set up for this project.fastlane will create a new Gemfile at path &apos;Gemfile&apos;This change is necessary for fastlane plugins to workShould fastlane modify the Gemfile at path &apos;Gemfile&apos; for you?(y/n) 输入y按回车，出现 12Installing plugin dependencies...Successfully installed plugins 便是安装成功了。 Fastlane配置1.打开终端，进入你的项目工程的根目录，输入以下命令： 1fastlane init 中间会让你输入苹果开发者账号的账号和密码，之后会在你项目工程的目录下生成一个fastlane文件夹，里面有Fastlane的配置文件，一个是Appfile文件，一个是Fastfile文件(如果要上传AppStore的话还有Deliverfile文件)。Appfile保存苹果开发者的相关信息、项目的相关信息等。Fastfile是运行脚本。 2.编辑Fastfile文件有时候一天需要打好几个包，为了区分，我们这里实现一个递增build号的功能。 (1)修改项目工程配置修改Build Settings中的Versioning配置，Current Project Version随便填一个，Versioning System选择Apple Generic。 修改Info.plist File路径 (2)定义一个递增build号的函数，添加到Fastfile中 123456789101112131415161718192021222324def updateProjectBuildNumbercurrentTime = Time.new.strftime(&quot;%Y%m%d&quot;)build = get_build_number()if build.include?&quot;#&#123;currentTime&#125;.&quot;# =&gt; 为当天版本 计算迭代版本号lastStr = build[build.length-2..build.length-1]lastNum = lastStr.to_ilastNum = lastNum + 1lastStr = lastNum.to_sif lastNum &lt; 10lastStr = lastStr.insert(0,&quot;0&quot;)endbuild = &quot;#&#123;currentTime&#125;.#&#123;lastStr&#125;&quot;else# =&gt; 非当天版本 build 号重置build = &quot;#&#123;currentTime&#125;.01&quot;endputs(&quot;*************| 更新build #&#123;build&#125; |*************&quot;)# =&gt; 更改项目 build 号increment_build_number(build_number: &quot;#&#123;build&#125;&quot;)end 实现自动打包的完整Fastfile如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566# 定义fastlane版本号fastlane_version “2.46.1” # 定义打包平台default_platform :iosdef updateProjectBuildNumbercurrentTime = Time.new.strftime(&quot;%Y%m%d&quot;)build = get_build_number()if build.include?&quot;#&#123;currentTime&#125;.&quot;# =&gt; 为当天版本 计算迭代版本号lastStr = build[build.length-2..build.length-1]lastNum = lastStr.to_ilastNum = lastNum + 1lastStr = lastNum.to_sif lastNum &lt; 10lastStr = lastStr.insert(0,&quot;0&quot;)endbuild = &quot;#&#123;currentTime&#125;.#&#123;lastStr&#125;&quot;else# =&gt; 非当天版本 build 号重置build = &quot;#&#123;currentTime&#125;.01&quot;endputs(&quot;*************| 更新build #&#123;build&#125; |*************&quot;)# =&gt; 更改项目 build 号increment_build_number(build_number: &quot;#&#123;build&#125;&quot;)end#指定项目的scheme名称scheme=“TestCI”#蒲公英api_key和user_keyapi_key=“”user_key=“”# 任务脚本platform :ios dolane :development_build do|options|branch = options[:branch]puts “开始打development ipa”updateProjectBuildNumber #更改项目build号# 开始打包gym(#输出的ipa名称output_name:”#&#123;scheme&#125;_#&#123;get_build_number()&#125;”,# 是否清空以前的编译信息 true：是clean:true,# 指定打包方式，Release 或者 Debugconfiguration:&quot;Release&quot;,# 指定打包所使用的输出方式，目前支持app-store, package, ad-hoc, enterprise, developmentexport_method:&quot;development&quot;,# 指定输出文件夹output_directory:&quot;./fastlane/build&quot;,)puts &quot;开始上传蒲公英&quot;# 开始上传蒲公英pgyer(api_key: “#&#123;api_key&#125;”, user_key: “#&#123;user_key&#125;”)endend 注意：蒲公英的 api_key 和 user_key，开发者在自己账号下的 账号设置-API信息 中可以找到。打其它类型的包的方法与development类似，可自定义一个新的lane实现。 在终端输入 1fastlane development_build 便会进行自动打包并上传蒲公英了。 Jenkins安装Jenkins 是一个开源项目，提供了一种易于使用的持续集成系统，使开发者从繁杂的集成中解脱出来，专注于更为重要的业务逻辑实现上。同时 Jenkins 能实施监控集成中存在的错误，提供详细的日志文件和提醒功能，还能用图表的形式形象地展示项目构建的趋势和稳定性。 安装过程如下：1.点击 http://mirrors.jenkins.io/war-stable/latest/jenkins.war 下载最新的Jenkins.war 2.打开终端，进入war包所在目录，执行以下命令： 1java -jar jenkins.war 注意：Jenkins依赖于Java运行环境，因此需要首先安装JDK,下载地址：http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html 3.执行完成之后打开浏览器输入http://localhost:8080/ 4.弹出Jenkins安装界面，会让你输入安全密码,输入完成之后选择默认安装。 5.新建管理员账号密码 对以上过程有疑问的话可以参考手把手教你利用Jenkins持续集成iOS项目 安装插件还是登录http://localhost:8080/ ，选择系统管理 - 管理插件。 安装GitLab插件在可选插件中选择GitLab Plugin和Gitlab Hook Plugin进行安装。 安装Xcode插件在可选插件中选择Xcode integration进行安装。 安装完成之后，我们就可以配置构建项目了。 构建任务1.点击新建，输入名称，构建一个自由风格的软件项目 2.配置Git 添加Git仓库地址，可以是HTTP也可以是SSH。点击Add 如果是HTTP 如果是SSH 注意：UserName是取一个名字，填写的Key是私钥。 3.配置脚本 因为我的Git仓库的目录是这样的 所以在执行fastlane development_build之前需要进入TestCI目录，即fastlane文件夹所在目录。 4.添加完成之后点击立即构建 5.执行成功显示如下 可以点击进入查看控制台输出 参考链接 http://www.jianshu.com/p/dac1ce3d7de8 http://www.jianshu.com/p/7b3f9cacc2ba https://www.pgyer.com/doc/view/fastlane http://www.jianshu.com/p/41ecb06ae95f","tags":[{"name":"iOS","slug":"iOS","permalink":"//breadawesome.me/tags/iOS/"},{"name":"Jenkins","slug":"Jenkins","permalink":"//breadawesome.me/tags/Jenkins/"}]},{"title":"我为什么要写博客？","date":"2017-07-12T12:49:05.000Z","path":"2017/07/12/why-blog/","text":"早就有想写博客的想法。但总是觉得自己的能力不足，所以迟迟没有动手。毕业工作，想法也有了改变。写博客更多是对生活的一种记录、总结。无论何等微不足道的举动．只要日日坚持．从中总会产生出某些类似观念的东西来。","tags":[{"name":"随笔","slug":"随笔","permalink":"//breadawesome.me/tags/随笔/"}]},{"title":"Mac下使用Hexo+Github搭建个人博客","date":"2017-07-12T12:14:50.000Z","path":"2017/07/12/hexo-blog/","text":"一、前言Hexo是一个快速、简洁且高效的博客框架，最近有搭建个人博客的想法，便动手尝试了。 二、初始化1.安装Node.js去Node.js官网下载相应的安装包，一路安装即可。 2.安装GitMac下安装Xcode就自带Git。 3.注册Github账号并新建仓库注册过程就不多说了，注册完成之后需要新建一个仓库。需要注意的是新创建的仓库的名字，必须是username.github.io。例如我的username是BreadAwesome，那么新创建的仓库的名字便是BreadAwesome.github.io。 4.配置SSH Key这一步不是必须的，配置SSH Key的话之后每次更新博客就不用都输入用户名和密码，可以方便一些。 以下是详细配置过程。(1)检查本机上是否已经存在SSH Key打开终端，输入如下命令 12cd .sshls -la 检查终端输出的文件列表中是否已经存在id_rsa.pub 或 id_dsa.pub 文件，如果文件已经存在，则直接进入第三步。 (2)创建一个SSH Key在终端输入如下命令 1ssh-keygen -t rsa -C &quot;your_email@example.com&quot; 按下回车，让你输入文件名，直接回车会创建使用默认文件名的文件(推荐使用默认文件名)，然后会提示你输入两次密码，可以为空。 (3)添加SSH Key到Github 如果你没有指定文件名（也就是使用的默认文件名），那么你的.ssh文件夹下，应该有一个id_rsa.pub文件了，打开该文件，复制里面的文本。然后登录Github，点击右上角头像右边的三角图标，点击Settings，然后在左边菜单栏点击SSH and GPG keys，点击New SSH key，Title 随便填一个，在Key栏填入你复制的内容，点击Add SSH key，就添加成功了。 (4)检验SSH Key是否配置成功在终端输入如下命令 1ssh -T git@github.com 如果出现 1Are you sure you want to continue connecting (yes/no)? 请输入yes再按回车。 如果最后出现 1Hi username! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 就说明你的SSH Key配置成功了。 5.安装Hexo前面我们已经安装了Node.js，这里我们使用npm命令来安装Hexo 1npm install -g hexo 等待一会就会完成下载安装。 接着在任意位置创建一个文件夹，如Blog，cd到该路径下执行以下命令 1hexo init 该命令会在目标文件夹内建立网站所需要的所有文件。接下来是安装依赖包 1npm install 到这里本地博客就搭建好了。执行以下命令（在你博客的对应文件夹路径下） 12hexo generatehexo server 在浏览器输入http://localhost:4000/ 就可以进行查看了。当然这个博客是本地的，别人是无法访问的，之后我们需要部署到GitHub上。 6.同步本地博客到Github编辑自己创建的本地博客文件夹中的_config.yml中的deploy节点 1234deploy: type: git repo: git@github.com:username/username.github.io.git branch: master 注意：repo为这种形式的是配置了SSH Key之后的，如果没有配置则使用Https形式的地址。 为了能够使Hexo部署到GitHub上，需要安装一个插件 1npm install hexo-deployer-git --save 然后输入以下命令 123hexo cleanhexo generatehexo deploy 在浏览器输入username.github.io就可以访问你的博客了。 三、配置主题Hexo主题在Github上有很多，如 https://github.com/iissnan/hexo-theme-next https://github.com/litten/hexo-theme-yilia https://github.com/viosey/hexo-theme-material https://github.com/LouisBarranqueiro/hexo-theme-tranquilpeak https://github.com/pinggod/hexo-theme-apollo https://github.com/ppoffice/hexo-theme-icarus 挑选自己喜欢的一款。当然，自己能够DIY也是极好的。 四、发布新文章执行以下命令 1hexo new post &apos;文章标题&apos; 这样会在本地博客的source-&gt;_posts路径下看到新建的文章，是md格式的，找一个markdown文本编辑器进行编辑即可。 编辑完成之后，与上面一样，执行以下命令 123hexo cleanhexo generatehexo deploy 即可更新到Github上。 五、绑定个人域名如果你想拥有一个炫酷的域名，那就往下看吧 （1）购买域名可以去万网买，也可以去其它地方。具体购买过程就不多讲了。 （2）配置DNS地址这里以万网为例。进入万网的管理控制台进行修改，修改DNS为DNSPod的免费DNS地址：f1g1ns1.dnspod.net 和 f1g1ns2.dnspod.net (3)域名解析注册一个DNSPod账号，登录之后把我们新注册的域名加进去，在域名解析界面添加3条记录 123@ A 192.30.252.153@ A 192.30.252.154www CNAME username.github.io. 如图所示。 (4)添加CNAME文件新建一个名为CNAME的文件，无后缀，内容为你的域名地址。将该文件放入本地博客的source文件夹里面，并更新到Github。 到这里就绑定域名成功了。 参考链接 http://www.jianshu.com/p/2cfa48c9c5eb http://www.jianshu.com/p/fb0b0258362f https://github.com/litten/hexo-theme-yilia http://crazymilk.github.io/2015/12/28/GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2","tags":[{"name":"Blog","slug":"Blog","permalink":"//breadawesome.me/tags/Blog/"},{"name":"Hexo","slug":"Hexo","permalink":"//breadawesome.me/tags/Hexo/"},{"name":"Github","slug":"Github","permalink":"//breadawesome.me/tags/Github/"}]}]